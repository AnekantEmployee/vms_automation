import time
import pandas as pd
from cve_search.main import combined_cve_search
from components.identify_vulnerability import get_gemini_model

def select_best_cve_with_llm(vulnerability, cve_results, llm_client=None):
    """
    Use LLM to select the most relevant CVE for a specific vulnerability
    """
    if len(cve_results) <= 1:
        return cve_results[0] if cve_results else None
    
    # Prepare context for LLM
    cve_summaries = []
    for i, cve in enumerate(cve_results):
        cve_summaries.append(f"""
CVE #{i+1}: {cve.cve_id}
Severity: {cve.severity}
CVSS Score: {cve.score}
Description: {cve.description[:200]}...
""")
    
    prompt = f"""
Given the vulnerability: "{vulnerability}"

Please analyze the following CVE entries and select the most relevant one for this specific vulnerability context:

{chr(10).join(cve_summaries)}

Consider these factors when selecting:
1. Direct relevance to the vulnerability type
2. Severity and potential impact
3. Likelihood of exploitation in the given context
4. CVSS score and risk level

For example, when there is improper input validation, different attacks such as Cross-Site Scripting (XSS) and SQL Injection can occur. If an attacker is able to exploit these vulnerabilities through various attack scenarios, the severity of the risk changes. Based on the severity, the CVSS (Common Vulnerability Scoring System) score will also change.

Please respond with only the CVE number (e.g., CVE-2024-42244) of the most relevant entry.
"""
    
    try:
        if llm_client:
            print("🤖 Querying LLM for CVE selection...")
            
            time.sleep(2)
            
            response = llm_client.invoke(prompt)
            if hasattr(response, 'content'):
                response_text = response.content
            else:
                response_text = str(response)
            
            # Extract CVE ID using more robust pattern matching
            import re
            cve_pattern = r'CVE-\d{4}-\d{4,7}'
            matches = re.findall(cve_pattern, response_text)
            
            if matches:
                selected_cve_id = matches[0].strip()
                # Find the selected CVE in results
                for cve in cve_results:
                    if cve.cve_id == selected_cve_id:
                        return cve
        
        # Fallback: select highest severity CVE
        severity_order = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'UNKNOWN': 0}
        return max(cve_results, key=lambda x: (severity_order.get(x.severity.upper(), 0), x.score))
        
    except Exception as e:
        print(f"LLM selection failed: {e}. Falling back to highest severity CVE.")
        severity_order = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'UNKNOWN': 0}
        return max(cve_results, key=lambda x: (severity_order.get(x.severity.upper(), 0), x.score))

def extract_solution_from_cve(cve_result):
    """
    Extract solution/mitigation information from CVE references
    """
    if not cve_result or not hasattr(cve_result, 'references'):
        return "No solution information available"
    
    # Look for patch/fix references
    patch_keywords = ['patch', 'fix', 'commit', 'release', 'security', 'advisory']
    solution_refs = []
    
    for ref in cve_result.references:
        ref_lower = ref.lower()
        if any(keyword in ref_lower for keyword in patch_keywords):
            solution_refs.append(ref)
    
    if solution_refs:
        # Clean up references and limit to first 2
        clean_refs = [ref.strip() for ref in solution_refs[:2]]
        return f"Recommended actions: {', '.join(clean_refs)}"
    
    return "Update to latest version or apply vendor security patches"

def finding_vulnerability_node(state, llm_client=None):
    """
    Process the findings DataFrame to perform detailed CVE analysis and enrichment
    """
    findings_df = state.get("findings_df", pd.DataFrame())
    enriched_df = pd.DataFrame()
    total_cves = 0
    
    try:
        print("\n🛡️ Starting detailed vulnerability analysis...")
        
        if not state.get("success", False):
            raise Exception("Previous node failed or no data available")
        
        findings_df = state["findings_df"]
        
        if findings_df.empty:
            print("⚠️ No findings to analyze - skipping detailed vulnerability analysis")
            return {
                "success": True,
                "error": None,
                "enriched_findings_df": findings_df,
                "total_cves_found": 0
            }
        
        # Create a copy to avoid modifying the original
        enriched_df = findings_df.copy()
        
        # Add new columns for CVE data
        cve_columns = {
            'CVE_ID': "None found",
            'CVE_Severity': "N/A",
            'CVE_CVSS_Score': 0.0,
            'CVE_Description': "No CVE description available",
            'CVE_Solution': "Follow general security best practices",
            'All_Related_CVEs': "None"
        }
        
        for col, default_val in cve_columns.items():
            if col not in enriched_df.columns:
                enriched_df[col] = default_val
        
        # Process each vulnerability with rate limiting
        total_vulnerabilities = len(enriched_df)
        for idx, row in enriched_df.iterrows():
            if not pd.isna(row.get('Vulnerability')):
                vulnerability = row['Vulnerability']
                current_vuln = idx + 1
                
                print(f"\n🔍 Analyzing vulnerability {current_vuln}/{total_vulnerabilities}: {vulnerability}")
                print("⏳ Checking Gemini quota limits...")
                
                # Perform detailed CVE search
                cve_results = combined_cve_search(vulnerability, max_results=10)
                
                if cve_results:
                    print(f"Found {len(cve_results)} related CVEs")
                    total_cves += len(cve_results)
                    
                    # Store all CVE IDs for reference
                    all_cve_ids = [cve.cve_id for cve in cve_results]
                    enriched_df.at[idx, 'All_Related_CVEs'] = ", ".join(all_cve_ids)
                    
                    # Select the best/most relevant CVE with rate limiting
                    selected_cve = select_best_cve_with_llm(
                        vulnerability, 
                        cve_results, 
                        llm_client or get_gemini_model()
                    )
                    
                    if selected_cve:
                        print(f"✅ Selected CVE: {selected_cve.cve_id} (Severity: {selected_cve.severity}, Score: {selected_cve.score})")
                        
                        # Populate the new columns with selected CVE data
                        enriched_df.at[idx, 'CVE_ID'] = selected_cve.cve_id
                        enriched_df.at[idx, 'CVE_Severity'] = selected_cve.severity
                        enriched_df.at[idx, 'CVE_CVSS_Score'] = selected_cve.score
                        enriched_df.at[idx, 'CVE_Description'] = (
                            selected_cve.description[:500] + "..."
                            if len(selected_cve.description) > 500
                            else selected_cve.description
                        )
                        enriched_df.at[idx, 'CVE_Solution'] = extract_solution_from_cve(selected_cve)
                    
                    # Add delay after processing each vulnerability to prevent quota exhaustion
                    if current_vuln < total_vulnerabilities:  # Don't delay after the last one
                        print("⏸️  Waiting 3 seconds to prevent Gemini quota exhaustion...")
                        time.sleep(3)  # 3 second delay between vulnerabilities
                else:
                    print("⚠️ No CVEs found for this vulnerability")                    
        
        print(f"\n✓ Completed vulnerability analysis. Processed {len(enriched_df)} vulnerabilities with {total_cves} total CVEs found")
        return {
            "success": True,
            "error": None,
            "enriched_findings_df": enriched_df,
            "total_cves_found": total_cves
        }
        
    except Exception as e:
        print(f"✗ Error in finding_vulnerability_node: {str(e)}")
        return {
            "success": False,
            "error": str(e),
            "enriched_findings_df": enriched_df if not enriched_df.empty else findings_df,
            "total_cves_found": total_cves
        }